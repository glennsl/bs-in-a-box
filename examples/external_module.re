
/* 
 * This example shows how to include an external module
 */

type context;
[@bs.val] [@bs.module "vm"] external createContext : Js.t({..}) => context = "";
[@bs.val] [@bs.module "vm"] external runInContext : (string, context) => unit = "";

/*  The generated JS code of our external module */
let myExternalCode = {|
  // Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
  "use strict";

  function hello(name) {
    return "Hello " + (String(name) + ", I'm from an external module!\"");
  }

  exports.hello = hello;
  /* No side effect */
|};

/* Our dynamically compiled code will use `require` to load external modules, so we need to 
   override/create the require function and lookup up our external module, or if not found
   pass it on to the original require function, if any.Arg
   
   Note that the compiler will emit `require('stdlib/myExternal)`, so we have to give that
   as the lookup name. External JS modules will be required as normal, however.
*/
let externalModules = {j|
  require = (function (modules, cache) {
    var originalRequire = typeof require == "function" && require;

    return function (name) {
      if (!cache[name]) {
        if (!modules[name]) {
          if (originalRequire)
            return originalRequire(name);

          throw new Error("Cannot find module '" + name + "'");
        }

        var exports = cache[name] = {};

        modules[name].call(exports, exports);
      }

      return cache[name];
    };
  })(
    {
      "stdlib/myExternal": function(exports) { $myExternalCode }
    },
    {}
  );
|j};

/* Load the type information for the compiler */
BsBox.loadModule(
  ~name="MyExternal",
  ~cmi=[%raw {|"Caml1999I017\x84\x95\xa6\xbe\0\0\0f\0\0\0\x19\0\0\0V\0\0\0Q\xa0*MyExternal\xa0\xa0\xb0\x01\x03\xf3%hello@\xc0\xb0\xc1 \xb0\xb3\x90\xb0C&string@@\x90@\x02\x05\xf5\xe1\0\0\xfc\xb0\xb3\x90\xb0C&string@@\x90@\x02\x05\xf5\xe1\0\0\xfd@\x02\x05\xf5\xe1\0\0\xfe@\xb0\xc0&_none_A@\0\xff\x04\x02A@@\x84\x95\xa6\xbe\0\0\0\xf3\0\0\0(\0\0\0\x90\0\0\0w\xa0\xa0*MyExternal\x900\x02LzF\xe5\xf4\xb2\xdc|\xa1\xf5\xde3\xe4\xdf\"\xa0\xa0&String\x900e\x90\x7f\x1d\xde\xc3+\xe4\xc8\xa1\x90\x07\x91p\xe0\xf1\xa0\xa0*Pervasives\x900\r\x01ZZ!6e\x9b\r\xe41\xbe\x7f\x15E\xbe\xa0\xa0)Js_string\x900GV\xce|\x10H7Ib\x80\x9b\xb5F\".u\xa0\xa0%Js_re\x9006s\xb2X\x9a=\x93\xf6=\x05#\0\xa2\r\xd3f\xa0\xa0(Js_array\x900\x92\x1e\xbe\x88=\x94\xf1y@\x9d\x98\xefN\xd6\xdc\x0f\xa0\xa0\"Js\x900\xd3g\x87\x88u\xa2\xf2\xe6\x1b\xad\xa9\xc5\x81\x85lF\xa0\xa08CamlinternalFormatBasics\x900\x8b\x06\x9f\xca\x1eM\x93\x16\xb5\x88\xe5UO8\xbb$@\x84\x95\xa6\xbe\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0@%"|}],
  ~cmj=[%raw {|"Caml1999I017\x84\x95\xa6\xbe\0\0\0D\0\0\0\x10\0\0\x008\0\0\x004\xa0*MyExternal\xa0\xa0\xb0\x01\x03\xf1%hello@\xc0\xb0\xb3\x90\xb0C&string@@\x90@\x02\x05\xf5\xe1\0\0\xfe@\xb0\xc0&_none_A@\0\xff\x04\x02A@@\x84\x95\xa6\xbe\0\0\0l\0\0\0\x0f\0\0\0:\0\0\0/\xa0\xa0*MyExternal\x900\xb3K@\b]?\xb6}\xec\xe1Q\xf5\x97\xb9\xe4\x06\xa0\xa0*Pervasives\x900\r\x01ZZ!6e\x9b\r\xe41\xbe\x7f\x15E\xbe\xa0\xa08CamlinternalFormatBasics\x900\x8b\x06\x9f\xca\x1eM\x93\x16\xb5\x88\xe5UO8\xbb$@\x84\x95\xa6\xbe\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0@%"|}]
);

let code  = {|
  let () =
    "joe" |> String.capitalize
          |> MyExternal.hello
          |> Js.log
|};

let result =
  BsBox.compile(code);

switch result {
| Ok({ code, warnings }) => {
    if (String.trim(warnings) !== "") {
      Js.log2("Warnings:\n", warnings);
    };

    /* Set up runtime environment */
    let context = createContext([%raw "{ console: console, exports: {} }"]);
    let stdlib = Node_fs.readFileSync("vendor/stdlibBundle.js", `utf8); /* TODO: Why on earth doesn't `Node.Fs` work? */
    runInContext(stdlib, context);

    /* Before running our compiled code, we have to add our external modules */
    runInContext(externalModules, context);
    
    /* And finally, evaluate our compiled code */
    runInContext(code, context);
  }
| Error(`BsCompileError({ message })) =>
  Js.log2("Error: ", message)
};
